# 모든 개발자를 위한 HTTP 웹 기본 지식

> 인프런 강의 '모든 개발자를 위한 HTTP 웹 기본 지식'을 수강하며 필기한 노트이다. 



## 1. 인터넷 네트워크

- **인터넷 통신**

  사람들이 지구 반대편에서도 서로 연락을 주고받고, 데이터를 보내고 받을 수 있는 것은 인터넷 통신이 있기 때문이다. 그러나 사용자에게는 간단해 보이는 이 과정은 일정한 규칙에 따른 여러 요청과 응답을 거쳐 이뤄진다. 

- **IP(Internet Protocol)**

  인터넷 통신에서 '주소'와 같은 것으로 이해할 수 있다. 인터넷 통신 시 연락을 주고, 연락을 받는 컴퓨터의 위치를 알려준다. 마치 택배 상자에 적힌 주소와 같이 말이다. 흔히 'IP 주소'라는 말을 사용하는 것도 같은 맥락이다. 

  요청을 보내는 컴퓨터(클라이언트)에서는 요청을 받을 컴퓨터(서버)로 데이터를 보낼 때 출발지 IP와 목적지 IP 정보를 데이터에 달아 보낸다. 데이터는 네트워크에 과부하가 일어나거나 속도가 느려지는 상황을 막기 위해 작게 쪼개져 전송되는데 이것을 패킷(packet)이라고 한다.  

  이런 IP 프로토콜은 아래와 같은 단점을 가지고 있다. 

  - 비연결성

    목적지 IP가 존재하지 않거나 서비스 불능인 상황이 발생할 수 있는데도 그를 사전에 확인할 수 없고, 일단 전송한다. '수신자 불명'이 적혀 돌아온 소포를 생각해보자. 보내기 전까지는 그 주소가 사라졌는지 모른다. 소포가 안 갔는데도 도착했다고 착각할 수도 있다. (물론 스마트폰의 존재는 잊는다는 가정이다)

  - 비신뢰성

    중간에 패킷이 사라질 수 있지만 책임을 안 진다. 또한 작게 쪼개진 패킷들은 순서대로 도착해야 원 데이터로 복원될 수 있는데, 이 패킷의 순서가 뒤바뀌어도 책임은 안 진다. 

  - 프로그램(애플리케이션) 구분의 모호성

    같은 IP를 사용하는 서버에서는 다수의 애플리케이션이 작동 중일 수 있다. IP만으로는 클라이언트에서 보낸 데이터가 어떤 애플리케이션으로 가야 하는지 모른다. 

  

  이런 단점을 보완해 주는 것이 바로 TCP이다. 

   

- **TCP, UDP**

  - **TCP(Transmission Control Protocol, 전송 제어 프로토콜)**

    현재 대부분의 네트워크에서 사용되는 프로토콜이며 데이터 전송과 연결에 있어 높은 신뢰성을 보장한다. **3 way handshake**라는 과정을 통해 클라이언트와 서버의 연결을 확인하고(비연결성 해결), **포트 번호**를 데이터에 붙이는 정보에 포함시키고 데이터 전송 확인 메시지를 보내 데이터의 전달을 보증한다(프로그램 구분 성공). 여기서 포트 번호는 전송된 데이터를 사용할 애플리케이션을 식별하는 데 사용된다. 또한 **일련번호**와 **확인 응답 번호**를 데이터에 붙이는 정보에 포함시켜 패킷의 순서가 뒤섞이는 것을 사전에 방지한다(비신뢰성 해결). 일련번호는 송신되는 데이터(패킷)가 몇 번째 데이터인지를 나타내며, 확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는가를 알려주는 번호이다.   

  - **UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)**

    IP와 차이가 거의 없고, 포트 번호와 체크섬 정도만 추가된다. 당연히 신뢰성이 보장되지 않고 IP의 일부 단점을 그대로 갖고 있다. 하지만 속도가 매우 빠르다. 

  

- **PORT**

  같은 IP를 가진 서버에서 여러 개의 애플리케이션이 동작하고 있을 때, 각 애플리케이션을 식별하는 데 쓰이는 번호이다. 포트 번호라고도 하며, 바로 이 번호를 통해 클라이언트-서버의 데이터가 정확한 위치로 전달될 수 있는 것이다.  

  포트 번호란 택배로 비유하면 어떤 아파트의 몇 동 몇 호와 같은 상세 주소이다. 어떤 시의 어떤 구, 어떤 동의 아파트까지 알려주는 것이 IP 주소라면, 그 아파트 내 수많은 가구 중 어떤 동의 어떤 호에 택배를 배달해야 하는지 알려주는 것이 포트 번호인 것이다.  

  

- **DNS(Domain Name System, 도메인 네임 시스템)**

  네트워크 통신 시 '도메인'이라는 것을 통해 보다 편리하게 서버와 연결될 수 있게 해주는 시스템이다. 도메인은 일종의 닉네임 같은 것으로, 우리가 일반적으로 알고 있는 링크 주소를 말한다. 예를 들어 구글은 www.google.com이라는 도메인을 가지고 있고, 네이버는 www.naver.com이라는 도메인을 가지고 있다. 

  왜 이런 도메인이 쓰이느냐 하면, IP 주소가 복잡하기 때문이다. 또 IP 주소는 변경될 수 있다. 서버와 클라이언트는 IP 주소로 통신하기 때문에 그런 상황이 생기면 난감해진다. 이런 문제를 해결하기 위해 **DNS 서버**라는 것을 사용하는데, 그 안에 IP주소와 도메인을 함께 등록해놓는다. 클라이언트는 이 DNS 서버에 도메인 이름을 보내며 그에 해당하는 IP 주소를 보내달라고 요청하고, DNS 서버는 해당 사이트의 IP 주소를 보내준다. IP가 변경될 경우, DNS 서버의 값만 수정하면 연결에 지장이 없게 된다.  



## 2. URI와 웹 브라우저의 흐름

- **URI(Uniform Resource Identifier)**

URI(Uniform Resource Identifier)는 네트워크에서 특정 자원을 식별할 수 있는 정보를 말한다. 괜히 자원이란 말이 어려워 보이지만, 이 자원은 결국 네트워크 내에서 사용할 수 있는 모든 것을 뜻한다. 컴퓨터의 프린터나 디스크 드라이브, 메모리, 데이터, 프로그램, 데이터베이스, 파일 등등. 이런 자원들을 바로 리소스(Resource)라고 부른다. URI란 바로 이런 리소스들 중 특정 리소스를 구별할 수 있게 해주는 정보인 것이다. 쉽게 비유하면 인터넷 통신 내에서의 주민등록번호라고 생각하면 된다. 

URI는 URL과 URN이라는 두 가지 요소를 포함한다.



- **URL(Uniform Resource Locater)**

리소스의 위치를 담고 있는 정보이다. 프로토콜(http, https)+호스트명+포트번호+패스+쿼리 파라미터로 구성되어 있으며 이 중 포트 번호는 생략할 수 있다. 

이유는 프로토콜에 따라 포트 번호가 대부분 고정되어 있기 때문이다. http는 80 포트, https는 443 포트를 사용한다. 호스트명은 도메인 명 또는 IP 주소이다. 

패스(path)는 리소스가 있는 경로를 말한다. 

쿼리 파라미터는 그냥 줄여서 쿼리라고도 하는데,  사용자가 웹 서버에서 찾으려는 데이터의 정보를 말한다. key=value 형태이며, ?로 시작하고 &로 추가할 수 있다. 대체로 문자열(string) 형태이기 때문에 쿼리 스트링(query string)이라고도 한다. 



- **URN(Uniform Resource Name)**

리소스를 부르는 명칭, 즉 이름인데 말 그대로 그냥 이름일 뿐이라 별 쓸모가 없다. 네트워크에서 쓰이는 것은 거의 위치에 해당하는 URL이다. 



- **웹 브라우저의 간략한 흐름**

  1. 클라이언트가 HTTP 요청 메시지를 보낸다.
  2. SOCKET 라이브러리가 OS로 메시지를 전달한다.
  3. TCP/IP 패킷이 생성된다. 이 과정에서 HTTP 메시지가 포함된다.
  4. 서버에서 HTTP 응답 메시지를 보낸다. 
  5. 응답 메시지를 받은 클라이언트가 웹 브라우저에 HTML을 렌더링한다.

  

## 3. HTTP

- **HTTP(Hypertext Transfer Protocol)**

   현재 서버간의 데이터를 주고 받을 때 사용하는 프로토콜(규칙)이다. 거의 모든 형태의 데이터를 다 전송할 수 있다. HTTP는 1991년에 개발되어 1996년 1.0버전, 1997년에 현재도 가장 많이 쓰이고 있는 1.1 버전이 개발되었다. 이 버전은 1999년, 2014년 두 번에 걸쳐 개선되었다. 그리고 2015년에는 HTTP/2 버전이 나왔고 현재는 HTTP/3도 나왔다. 

  이 HTTP/3 버전은 다른 버전들과 달리 TCP가 아닌 UDP를 사용하며(타 버전들은 모두 TCP 기반이다), 이전 버전보다 성능이 개선되었다. 현재 2, 3 버전도 꽤 많이 쓰이고 있다. (EX. 구글 검색 플랫폼)

  

- **무상태 프로토콜(Stateless Protocol)**

  **서버가 클라이언트의 상태, 정보를 보존하지 않는 것**을 말한다. 

  예를 들어, 어떤 고객이 휴대폰을 사려고 가격을 물어보았다고 하자. 점원은 100만원이라고 대답했다. 고객은 카드 할인을 통해 휴대폰을 싸게 구매할 수 있는지 궁금했다. 그러나 점원은 '무슨 휴대폰을 말씀하시는 건가요?'라고 대답했다.  고객은 화가 났지만 휴대폰의 제품명과 카드를 말하며 할인받을 수 있는지를 물었고, 점원은 80만원에 살 수 있다고 대답했다. 고객은 고민하다 점원에게 아까 그 휴대폰을 카드로 사겠다고 말한다. 점원은 이번에도 '무슨 휴대폰을 어떤 카드로 사시겠다는 건가요?' 라고 대답한다. 

  위 예의 점원처럼 클라이언트의 기존 정보를 기억하지 않는 것을 **무상태(stateless)**라고 부른다. 이 반대는 **상태 유지(Stateful)**로 서버가 클라이언트의 상태를 보존하는 것이다. 그러나 이를 기반으로 애플리케이션을 설계할 경우 아래와 같은 치명적인 단점이 생긴다. 

  

  - 항상 같은 서버를 유지해야 한다. 서버를 바꿀 경우 다른 서버에 정보를 전달해야 한다. 

  - 따라서 서버에 문제가 생기거나 장애가 일어날 경우 대처하기 힘들다.

    

  하지만 **무상태 프로토콜을 기반으로 애플리케이션을 설계한다면 위의 단점들을 피해갈 수 있다**. 애초에 클라이언트에 대한 정보를 보존하지 않으므로 연결 서버에 문제가 생겨도 금방 다른 서버로 바꿔 연결할 수 있다. 또한 갑자기 트래픽이 증가해도 서버의 양을 늘리는 작업이 용이하다. 

  이 때문에 웹 애플리케이션은 거의 무상태로 설계하며, 꼭 필요한 경우에만 최소한으로 상태 유지를 사용한다.  한 예로 사용자가 플랫폼 사이트에 로그인한 상태에서 작업을 진행할 때는 상태 유지가 필요하다. 

  

- **비연결성**
- **HTTP 메시지**