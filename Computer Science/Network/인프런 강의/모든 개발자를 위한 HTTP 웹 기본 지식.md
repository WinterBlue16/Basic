# 모든 개발자를 위한 HTTP 웹 기본 지식

> 인프런 강의 '모든 개발자를 위한 HTTP 웹 기본 지식'을 수강하며 필기한 노트이다. 



## 1. 인터넷 네트워크

- **인터넷 통신**

  사람들이 지구 반대편에서도 서로 연락을 주고받고, 데이터를 보내고 받을 수 있는 것은 인터넷 통신이 있기 때문이다. 그러나 사용자에게는 간단해 보이는 이 과정은 일정한 규칙에 따른 여러 요청과 응답을 거쳐 이뤄진다. 

- **IP(Internet Protocol)**

  인터넷 통신에서 '주소'와 같은 것으로 이해할 수 있다. 인터넷 통신 시 연락을 주고, 연락을 받는 컴퓨터의 위치를 알려준다. 마치 택배 상자에 적힌 주소와 같이 말이다. 흔히 'IP 주소'라는 말을 사용하는 것도 같은 맥락이다. 

  요청을 보내는 컴퓨터(클라이언트)에서는 요청을 받을 컴퓨터(서버)로 데이터를 보낼 때 출발지 IP와 목적지 IP 정보를 데이터에 달아 보낸다. 데이터는 네트워크에 과부하가 일어나거나 속도가 느려지는 상황을 막기 위해 작게 쪼개져 전송되는데 이것을 패킷(packet)이라고 한다.  

  이런 IP 프로토콜은 아래와 같은 단점을 가지고 있다. 

  - 비연결성

    목적지 IP가 존재하지 않거나 서비스 불능인 상황이 발생할 수 있는데도 그를 사전에 확인할 수 없고, 일단 전송한다. '수신자 불명'이 적혀 돌아온 소포를 생각해보자. 보내기 전까지는 그 주소가 사라졌는지 모른다. 소포가 안 갔는데도 도착했다고 착각할 수도 있다. (물론 스마트폰의 존재는 잊는다는 가정이다)

  - 비신뢰성

    중간에 패킷이 사라질 수 있지만 책임을 안 진다. 또한 작게 쪼개진 패킷들은 순서대로 도착해야 원 데이터로 복원될 수 있는데, 이 패킷의 순서가 뒤바뀌어도 책임은 안 진다. 

  - 프로그램(애플리케이션) 구분의 모호성

    같은 IP를 사용하는 서버에서는 다수의 애플리케이션이 작동 중일 수 있다. IP만으로는 클라이언트에서 보낸 데이터가 어떤 애플리케이션으로 가야 하는지 모른다. 

  

  이런 단점을 보완해 주는 것이 바로 TCP이다. 

   

- **TCP, UDP**

  - **TCP(Transmission Control Protocol, 전송 제어 프로토콜)**

    현재 대부분의 네트워크에서 사용되는 프로토콜이며 데이터 전송과 연결에 있어 높은 신뢰성을 보장한다. **3 way handshake**라는 과정을 통해 클라이언트와 서버의 연결을 확인하고(비연결성 해결), **포트 번호**를 데이터에 붙이는 정보에 포함시키고 데이터 전송 확인 메시지를 보내 데이터의 전달을 보증한다(프로그램 구분 성공). 여기서 포트 번호는 전송된 데이터를 사용할 애플리케이션을 식별하는 데 사용된다. 또한 **일련번호**와 **확인 응답 번호**를 데이터에 붙이는 정보에 포함시켜 패킷의 순서가 뒤섞이는 것을 사전에 방지한다(비신뢰성 해결). 일련번호는 송신되는 데이터(패킷)가 몇 번째 데이터인지를 나타내며, 확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는가를 알려주는 번호이다.   

  - **UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)**

    IP와 차이가 거의 없고, 포트 번호와 체크섬 정도만 추가된다. 당연히 신뢰성이 보장되지 않고 IP의 일부 단점을 그대로 갖고 있다. 하지만 속도가 매우 빠르다. 

  

- **PORT**

  같은 IP를 가진 서버에서 여러 개의 애플리케이션이 동작하고 있을 때, 각 애플리케이션을 식별하는 데 쓰이는 번호이다. 포트 번호라고도 하며, 바로 이 번호를 통해 클라이언트-서버의 데이터가 정확한 위치로 전달될 수 있는 것이다.  

  포트 번호란 택배로 비유하면 어떤 아파트의 몇 동 몇 호와 같은 상세 주소이다. 어떤 시의 어떤 구, 어떤 동의 아파트까지 알려주는 것이 IP 주소라면, 그 아파트 내 수많은 가구 중 어떤 동의 어떤 호에 택배를 배달해야 하는지 알려주는 것이 포트 번호인 것이다.  

  

- **DNS(Domain Name System, 도메인 네임 시스템)**

  네트워크 통신 시 '도메인'이라는 것을 통해 보다 편리하게 서버와 연결될 수 있게 해주는 시스템이다. 도메인은 일종의 닉네임 같은 것으로, 우리가 일반적으로 알고 있는 링크 주소를 말한다. 예를 들어 구글은 www.google.com이라는 도메인을 가지고 있고, 네이버는 www.naver.com이라는 도메인을 가지고 있다. 

  왜 이런 도메인이 쓰이느냐 하면, IP 주소가 복잡하기 때문이다. 또 IP 주소는 변경될 수 있다. 서버와 클라이언트는 IP 주소로 통신하기 때문에 그런 상황이 생기면 난감해진다. 이런 문제를 해결하기 위해 **DNS 서버**라는 것을 사용하는데, 그 안에 IP주소와 도메인을 함께 등록해놓는다. 클라이언트는 이 DNS 서버에 도메인 이름을 보내며 그에 해당하는 IP 주소를 보내달라고 요청하고, DNS 서버는 해당 사이트의 IP 주소를 보내준다. IP가 변경될 경우, DNS 서버의 값만 수정하면 연결에 지장이 없게 된다.  



## 2. URI와 웹 브라우저의 흐름

- **URI(Uniform Resource Identifier)**

URI(Uniform Resource Identifier)는 네트워크에서 특정 자원을 식별할 수 있는 정보를 말한다. 괜히 자원이란 말이 어려워 보이지만, 이 자원은 결국 네트워크 내에서 사용할 수 있는 모든 것을 뜻한다. 컴퓨터의 프린터나 디스크 드라이브, 메모리, 데이터, 프로그램, 데이터베이스, 파일 등등. 이런 자원들을 바로 리소스(Resource)라고 부른다. URI란 바로 이런 리소스들 중 특정 리소스를 구별할 수 있게 해주는 정보인 것이다. 쉽게 비유하면 인터넷 통신 내에서의 주민등록번호라고 생각하면 된다. 

URI는 URL과 URN이라는 두 가지 요소를 포함한다.



- **URL(Uniform Resource Locater)**

리소스의 위치를 담고 있는 정보이다. 프로토콜(http, https)+호스트명+포트번호+패스+쿼리 파라미터로 구성되어 있으며 이 중 포트 번호는 생략할 수 있다. 

이유는 프로토콜에 따라 포트 번호가 대부분 고정되어 있기 때문이다. http는 80 포트, https는 443 포트를 사용한다. 호스트명은 도메인 명 또는 IP 주소이다. 

패스(path)는 리소스가 있는 경로를 말한다. 

쿼리 파라미터는 그냥 줄여서 쿼리라고도 하는데,  사용자가 웹 서버에서 찾으려는 데이터의 정보를 말한다. key=value 형태이며, ?로 시작하고 &로 추가할 수 있다. 대체로 문자열(string) 형태이기 때문에 쿼리 스트링(query string)이라고도 한다. 



- **URN(Uniform Resource Name)**

리소스를 부르는 명칭, 즉 이름인데 말 그대로 그냥 이름일 뿐이라 별 쓸모가 없다. 네트워크에서 쓰이는 것은 거의 위치에 해당하는 URL이다. 



- **웹 브라우저의 간략한 흐름**

  1. 클라이언트가 HTTP 요청 메시지를 보낸다.
  2. SOCKET 라이브러리가 OS로 메시지를 전달한다.
  3. TCP/IP 패킷이 생성된다. 이 과정에서 HTTP 메시지가 포함된다.
  4. 서버에서 HTTP 응답 메시지를 보낸다. 
  5. 응답 메시지를 받은 클라이언트가 웹 브라우저에 HTML을 렌더링한다.

  

## 3. HTTP

- **HTTP(Hypertext Transfer Protocol)**

   현재 서버간의 데이터를 주고 받을 때 사용하는 프로토콜(규칙)이다. 거의 모든 형태의 데이터를 다 전송할 수 있다. HTTP는 1991년에 개발되어 1996년 1.0버전, 1997년에 현재도 가장 많이 쓰이고 있는 1.1 버전이 개발되었다. 이 버전은 1999년, 2014년 두 번에 걸쳐 개선되었다. 그리고 2015년에는 HTTP/2 버전이 나왔고 현재는 HTTP/3도 나왔다. 

  이 HTTP/3 버전은 다른 버전들과 달리 TCP가 아닌 UDP를 사용하며(타 버전들은 모두 TCP 기반이다), 이전 버전보다 성능이 개선되었다. 현재 2, 3 버전도 꽤 많이 쓰이고 있다. (EX. 구글 검색 플랫폼)

  

- **무상태 프로토콜(Stateless Protocol)**

  **서버가 클라이언트의 상태, 정보를 보존하지 않는 것**을 말한다. 

  예를 들어, 어떤 고객이 휴대폰을 사려고 가격을 물어보았다고 하자. 점원은 100만원이라고 대답했다. 고객은 카드 할인을 통해 휴대폰을 싸게 구매할 수 있는지 궁금했다. 그러나 점원은 '무슨 휴대폰을 말씀하시는 건가요?'라고 대답했다.  고객은 화가 났지만 휴대폰의 제품명과 카드를 말하며 할인받을 수 있는지를 물었고, 점원은 80만원에 살 수 있다고 대답했다. 고객은 고민하다 점원에게 아까 그 휴대폰을 카드로 사겠다고 말한다. 점원은 이번에도 '무슨 휴대폰을 어떤 카드로 사시겠다는 건가요?' 라고 대답한다. 

  위 예의 점원처럼 클라이언트의 기존 정보를 기억하지 않는 것을 **무상태(stateless)**라고 부른다. 이 반대는 **상태 유지(Stateful)**로 서버가 클라이언트의 상태를 보존하는 것이다. 그러나 이를 기반으로 애플리케이션을 설계할 경우 아래와 같은 치명적인 단점이 생긴다. 

  

  - 항상 같은 서버를 유지해야 한다. 서버를 바꿀 경우 다른 서버에 정보를 전달해야 한다. 

  - 따라서 서버에 문제가 생기거나 장애가 일어날 경우 대처하기 힘들다.

    

  하지만 **무상태 프로토콜을 기반으로 애플리케이션을 설계한다면 위의 단점들을 피해갈 수 있다**. 애초에 클라이언트에 대한 정보를 보존하지 않으므로 연결 서버에 문제가 생겨도 금방 다른 서버로 바꿔 연결할 수 있다. 또한 갑자기 트래픽이 증가해도 서버의 양을 늘리는 작업이 용이하다. 

  이 때문에 웹 애플리케이션은 거의 무상태로 설계하며, 꼭 필요한 경우에만 최소한으로 상태 유지를 사용한다.  한 예로 사용자가 플랫폼 사이트에 로그인한 상태에서 작업을 진행할 때는 상태 유지가 필요하다. 

  

- **비연결성**

   HTTP에서 필요할 때만 서버와 연결을 유지하고, 그렇지 않은 경우에는 연결을 종료하는 것을 말한다. 클라이언트와 서버가 서로 데이터를 주고받기 위해서는 연결이 필요하지만, 데이터를 이미 전송한 후 등 더 이상 할 작업이 없는 상황에도 연결을 유지하면 서버의 자원이 계속해서 낭비된다. 그래서 최소한의 자원을 사용하기 위해 데이터 응답이 끝나면 바로 연결을 끊는다. 

   HTTP는 기본적으로 연결을 유지하지 않도록 되어 있다. 또한 일반적으로 초 단위 이하의 빠른 속도로 응답하기에 수천 명이 서비스를 사용하더라도 실제 서버에서 동시에 처리하는 요청은 매우 작은 편이다. 이 덕분에 서버 자원을 매우 효율적으로 사용할 수 있다. 

   그러나 이 비연결성에도 아래와 같은 한계가 존재한다. 

   - 연결을 끊은 후 다시 TCP/IP 연결 시 3 way handshake 시간이 추가된다. 
   - 다시 연결을 하면서 웹 브라우저로 요청을 보내면 HTML뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 수많은 자원이 함께 다운로드되어 그만큼 시간이 걸리게 된다. 

   

   다행히 이런 단점은 HTTP 지속 연결로 해결되었다. 

   

   **HTTP 지속 연결(Persistent Connections)**

   HTTP 지속 연결(Persistent Connections)은 요청에 대한 모든 자원들을 받을 때까지 연결을 유지하는 것이다. 

   이전의 HTTP 연결은 파일 하나 하나 당 새로 연결하고 응답을 받는 형식이었기 때문에 새로운 연결 시 드는 시간과 자원을 상당히 줄일 수 있었다. 또한 HTTP/2, HTTP/3에서는 더 많은 최적화가 이루어졌다. 

   

   다만 이렇게 많은 점이 개선되어도 여전히 어려운 작업이 존재하는데, 바로 정확히 같은 시간에 사용자의 요청이 급증하는 경우이다. 대표적인 예가 수강신청과 명절 KTX 예약, 유명 가수의 콘서트 티켓팅이다. 당장 방탄소년단의 콘서트 티켓팅에 얼마만큼의 팬들이 몰리는지 생각해보자. 수만 명의 사람이 정확히 같은 시간에 요청을 보낸다면 서버에서 버틸 수가 없어진다. 이러한 엄청난 데이터 흐름은 분산 처리 등을 사용해 처리하는데, 많은 서버 개발자들이 어려워하는 업무 중 하나이다. 

   

- **HTTP 메시지**

   HTTP 통신에서 클라이언트와 서버가 서로에게 요청과 응답을 통보하는 메시지이다. 기본적인 구조는 아래의 그림과 같다.  

![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/40d236bc6feb4c7b8af8a05fb3049a7c/da1e10bd-c03d-4e9b-8487-44ff1c03df33.png)

메시지 구조는 시작 라인, HTTP 헤더, HTTP 메시지 바디로 이루어져 있다. 먼저 HTTP 요청 메시지를 살펴보자. 

- **HTTP 요청 메시지**

  **시작 라인**

  시작라인은 요청에 맞는 HTTP 메서드(GET, POST, PUT, etc) + 요청 대상 + HTTP 버전으로 구성되어 있다. 

  HTTP 메서드는 아래에서 자세하게 설명하겠다. 여기서는 GET이 데이터 조회, POST가 그 외의 데이터 처리를 담당한다는 간략한 사실만 알고 넘어가자.  

  요청 대상은 말 그대로 클라이언트가 원하는 데이터를 말한다. 만약 구글에서 hello를 검색하고 싶다고 하면, 여기에는 hello라는 검색어와 한글 버전으로 결과를 표시해달라는 의미를 담은 쿼리 스트링이 들어간다. (EX. /search?q=hello&hl=ko) 보통은 '/'로 시작하는 절대경로가 들어가며, 다른 유형으로 경로를 지정할 수도 있다.

  HTTP 버전은 현재 통신이 진행되고 있는 HTTP 버전이다.

  **HTTP 헤더**

  데이터 전송에 필요한 부가정보를 담고 있으며, 요청 메시지에서는 요청을 받는 서버의 도메인이 들어간다. 

  요청 메시지에서도 HTTP 메시지 바디를 입력할 수는 있으나 잘 쓰이지 않는다.

  

- **HTTP 응답 메시지**

  **시작 라인**

  **HTTP 버전+HTTP 상태 코드+이유 문구**로 구성된다. 

  HTTP 상태 코드는 클라이언트의 요청이 성공했는지 실패했는지를 나타낸다. 200대~500대의 번호로 표시되며 200대는 요청 성공을, 400대는 클라이언트 요청에 오류가 있음을, 500대는 서버 내부에 오류가 있음을 나타내는 코드이다. 아래서 자세하게 설명할 것이므로 여기까지만 알아두자.

  이유 문구는 메시지를 읽는 사람이 이해할 수 있도록 상태 코드를 설명한 짤막한 글이다. 위에서 200대가 요청 성공을 의미한다고 했는데, 이 때 이유 문구는 'OK'이다.  400대에서는 'Not Found'와 같은 이유 문구를 볼 수 있다. 

  **HTTP 헤더**

  메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증 클라이언트(브라우저) 정보 등이 포함된다. 필요시 임의의 헤더를 추가할 수 있다. 

  **HTTP 메시지 바디**

  클라이언트가 요청한 실제 데이터를 담고 있다. HTML 문서, 이미지, 영상, JSON 파일 등 byte로 표현할 수 있는 모든 데이터를 전송할 수 있다.  

  

## 4. HTTP API 만들기

 회사에서 서비스에 가입한 회원 관리 API를 설계하라는 지시를 받았다고 하자.  그럴 때 설계에서 중점을 두어야 할 점과 유의해야 할 점 등에 대해 알아보자. 

- 리소스 식별

  URI의 가장 중요한 기준은 리소스 식별이다. '어떤 자원', '무엇'을 관리할 것인가를 우선적으로 생각해야 한다.(EX. 미네랄을 캐라=> 리소스는 '미네랄') 회원 정보 관리가 목적이라면 여기서 리소스는 '회원 정보'가 된다. API를 만들 때는 이 리소스를 중심으로 설계해야 한다. 

  또한 리소스와 그 리소스로 하는 행위(수정, 삭제, 조회 등)는 분리해야 한다. URI는 아래와 같이, 오직 회원이라는 리소스만을 잡고 진행하도록 하자. 

  

![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/a286bd603b9a49cbabfa524eb3f27ac6/b5ed5e45-0d2c-4994-a03e-7440fd2efc86.png)

​	

 이 때문에 위의 URI로는 리소스 식별만 가능하며, 우리가 원하는 데이터 수정, 삭제, 추가 등의 작업을 진행하기 위해서는 별도의 작업이 필요하다. 이 때 쓰이는 것이 바로 HTTP 메서드이다. 



## 5. HTTP 메서드 

- 메서드(method)

  메서드는 클라이언트가 서버에 어떤 요청을 할 때, 기대하는 결과를 말한다. 따라서 HTTP 메서드란 클라이언트가 HTTP 프로토콜로 요청을 했을 때, 클라이언트가 받기를 기대하는 결과가 된다. 클라이언트가 보내는 요청은 매우 다양하기에, 그러한 요청을 우선 큰 분류로 나눠 처리한 후 응답하는 것이 효율적이다. 

  HTTP 메서드는 클라이언트가 원하는 결과인 동시에, 많은 클라이언트들의 요청을 처리하기 좋도록 분류한 집합을 의미하기도 한다. 

  HTTP 메서드에는 GET, POST, PUT, PATCH, DELETE 등이 있다. 그 중에서도 가장 보편적으로, 자주 쓰이는 메서드는 단연 GET과 POST이다. 

  

- GET

  ![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/9ffb5c2bc4a14eb99d6430fdecf8a2c6/ed3537dd-7e86-4b22-a0b3-533238626ba1.png)

  ```
  GET /search?=q=hello&hl=ko HTTP/1.1
  Host: www.google.com
  ```

  쉽게 말해 '데이터 내 놔'라고 말할 수 있다. 더 쉽게 말하면 '빨리 데이터 보게 내놓으라고.' 정도? 앞에서 알 수 있듯이 데이터베이스에 저장된 리소스들을 확인하고 싶을 때 사용한다. 

  서버에 전달하는 데이터는 문자열인 쿼리 파라미터(쿼리 스트링)을 통해 전달한다. 



- POST

  ![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/9ffb5c2bc4a14eb99d6430fdecf8a2c6/596c0832-c272-49ec-9449-145db02529c8.png)

  ![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/9ffb5c2bc4a14eb99d6430fdecf8a2c6/e04c144f-0891-4315-b096-e0051c71cd88.png)

  ```
  POST /members HTTP/1.1
  Content-Type: application/json
  {
  "username": "hello"
  "age": 20
  }
  ```

  두 가지 정도로 말할 수 있다. '이거 좀 등록해', '이거 어떻게 처리 좀 해'. 한국어에서 처리라는 말은 생각보다 많은 것을 포함한다. 그리고 이 POST 역시 그와 마찬가지이다. 주로 클라이언트가 보낸 데이터를 새로 등록할 때 많이 쓰이지만, 그거 아니더라도 온갖 잡다한 작업, 뭔가 판단하기 애매하다 싶은 작업은 죄다 POST로 퉁칠 수 있다.   

- PUT
- PATCH
- DELETE



## 6. HTTP 헤더- 전송 

- 단순 전송 
- 압축 전송
- 분할 전송
- 범위 전송

## 7. HTTP 헤더 - 정보

- From

- Referer

  현재 요청된 페이지의 이전 웹 페이지 주소를 말하며, 실무에서 많이 쓰이는 편

- User-Agent

- Server

- Date

## 8. HTTP 헤더 - 특별한 정보

- Host

  ![screen captures](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/68c8390a34d64755b00031ba6c63b3c7/8a30eb59-a210-4851-8b21-e44913110e00.png)

  요청에서 사용되는 정보로, 하나의 서버에서 여러 페이지가 열려 있는 상태일 때, 데이터가 어디로 가야 하는지 알려주는 위치 정보라고 보면 된다. 

- Location

- Allow

- Retry-After